<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Iceberg Floating Demo</title>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://unpkg.com/@turf/turf/turf.min.js"></script>
    <style>
        #classification {
            margin-top: 10px;
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body>
    <h1>Iceberg Floating and Classification Model</h1>
    <p>Draw an iceberg cross-section below, see how it floats, and receive a basic classification based on its shape. Please note, pinnacle is not currently supported in this version. Ongoing work to update the classifier is still in progress.

The goal is to show a scientific demo of how iceberg physics works.</p>
    <canvas id="canvas" width="800" height="500" style="border:1px solid black;"></canvas>
    <div id="classification">Draw an iceberg to see classification.</div>

<script>
$(function() {
    const canvas = $("#canvas")[0];
    const ctx = canvas.getContext("2d");

    const yZero = canvas.height / 3;
    let icebergs = [];
    let drawingInProgress = null;
    let lastClassification = null;

    // Draw background
    function draw_background() {
        ctx.fillStyle = "#bbddee";
        ctx.fillRect(0,0,canvas.width,canvas.height);

        // Horizon line
        ctx.beginPath();
        ctx.strokeStyle = "yellow";
        ctx.lineWidth = 1;
        ctx.moveTo(0,yZero);
        ctx.lineTo(canvas.width,yZero);
        ctx.stroke();

       

        draw_water();
    }

    function draw_water() {
        ctx.fillStyle = "#2c7bb6";
        ctx.beginPath();
        ctx.moveTo(0,yZero);
        ctx.lineTo(0,canvas.height);
        ctx.lineTo(canvas.width,canvas.height);
        ctx.lineTo(canvas.width,yZero);
        ctx.closePath();
        ctx.fill();
    }

    draw_background();

    // Geometry utilities
    function signedPolygonArea(vertices) {
        if (!vertices || vertices.length < 3) return 0;
        let total = 0;
        for (let i = 0; i < vertices.length; i++) {
            const addX = vertices[i][0];
            const addY = vertices[i == (vertices.length-1)?0:i+1][1];
            const subX = vertices[i == (vertices.length-1)?0:i+1][0];
            const subY = vertices[i][1];
            total += (addX*addY*0.5);
            total -= (subX*subY*0.5);
        }
        return total;
    }

    function polygonArea(vertices) { return Math.abs(signedPolygonArea(vertices)); }

    function rotate(cx, cy, x, y, angle){
        var rad=(Math.PI/180)*angle, cos=Math.cos(rad), sin=Math.sin(rad);
        var nx=(cos*(x-cx)) + (sin*(y-cy)) + cx;
        var ny=(cos*(y-cy)) - (sin*(x-cx)) + cy;
        return [nx,ny];
    }

    function pointSegmentDistance(p,v,w){
        function sqr(x){return x*x;}
        function dist2(v,w){return sqr(v[0]-w[0])+sqr(v[1]-w[1]);}
        const l2=dist2(v,w);
        if(l2===0) return Math.sqrt(dist2(p,v));
        let t=((p[0]-v[0])*(w[0]-v[0]) + (p[1]-v[1])*(w[1]-v[1]))/l2;
        t=Math.max(0,Math.min(1,t));
        return Math.sqrt(dist2(p,[v[0]+t*(w[0]-v[0]), v[1]+t*(w[1]-v[1])] ));
    }

    function centroid(pts){
        let n=pts.length, off=pts[0], x=0, y=0, f, p1, p2;
        let twicearea=0;
        for (let i=0,j=n-1;i<n;j=i++){
            p1=pts[i]; p2=pts[j];
            f=(p1[0]-off[0])*(p2[1]-off[1])-(p2[0]-off[0])*(p1[1]-off[1]);
            twicearea+=f; x+=(p1[0]+p2[0]-2*off[0])*f; y+=(p1[1]+p2[1]-2*off[1])*f;
        }
        f=twicearea*3;
        return [x/f+off[0], y/f+off[1]];
    }

    function polygonMomentOfInertia(points){
        function sub(a,b){return[a[0]-b[0],a[1]-b[1]];}
        function add(a,b){return[a[0]+b[0],a[1]+b[1]];}
        function mul(p,f){return[p[0]*f,p[1]*f];}
        function dot(a,b){return a[0]*b[0]+a[1]*b[1];}
        function cross(a,b){return a[0]*b[1]-b[0]*a[1];}
        function dist(a,b){b=b||[0,0];return Math.sqrt((a[0]-b[0])**2+(a[1]-b[1])**2);}
        let I=0;
        for(let i=1;i<points.length-1;i++){
            const p1=points[0],p2=points[i],p3=points[i+1];
            const w=dist(p1,p2), w1=Math.abs(dot(sub(p1,p2),sub(p3,p2))/w), w2=Math.abs(w-w1);
            const s=cross(sub(p3,p1),sub(p2,p1))/2;
            const h=2*Math.abs(s)/w;
            const p4=add(p2,mul(sub(p1,p2),w1/w));
            const cm1=[(p2[0]+p3[0]+p4[0])/3,(p2[1]+p3[1]+p4[1])/3];
            const cm2=[(p1[0]+p3[0]+p4[0])/3,(p1[1]+p3[1]+p4[1])/3];
            const I1=w1*h*((h*h/4)+(w1*w1/12)), I2=w2*h*((h*h/4)+(w2*w2/12));
            const m1=0.5*w1*h, m2=0.5*w2*h;
            const I1cm=I1-(m1*dist(cm1,p3)**2), I2cm=I2-(m2*dist(cm2,p3)**2);
            const I1p=I1cm+m1*dist(cm1)**2, I2p=I2cm+m2*dist(cm2)**2;
            if(cross(sub(p1,p3),sub(p4,p3))>0) I+=I1p; else I-=I1p;
            if(cross(sub(p4,p3),sub(p2,p3))>0) I+=I2p; else I-=I2p;
        }
        return Math.abs(I);
    }

    
    /* ============================================================
   POINT-BASED DRAWING (REPLACES SCRIBBLE)
============================================================ */

let drawingPoints = [];
let isDrawing = false;

function getMousePos(e){
    if(e.touches) e = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    return [e.clientX - rect.left, e.clientY - rect.top];
}

function redrawDraft(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    draw_background();

    if(drawingPoints.length === 0) return;

    // draw polygon edges
    ctx.strokeStyle = "black";
    ctx.lineWidth = 3;
    ctx.lineJoin = "round";
    ctx.beginPath();
    ctx.moveTo(drawingPoints[0][0], drawingPoints[0][1]);
    for(let i=1;i<drawingPoints.length;i++){
        ctx.lineTo(drawingPoints[i][0], drawingPoints[i][1]);
    }
    ctx.stroke();

    // draw vertices
    ctx.fillStyle = "red";
    drawingPoints.forEach(p=>{
        ctx.beginPath();
        ctx.arc(p[0], p[1], 4, 0, Math.PI*2);
        ctx.fill();
    });
}

// single click = add vertex
$('#canvas').on('click touchstart', function(e){
    if(icebergs.length > 0) return;

    drawingPoints.push(getMousePos(e));
    isDrawing = true;
    redrawDraft();
});

// double click = finish polygon
$('#canvas').on('dblclick', function(){
    if(!isDrawing || drawingPoints.length < 3) return;

    addIceberg(drawingPoints);          // ðŸ”’ unchanged
    classifyIceberg(icebergs[0]);       // ðŸ”’ unchanged

    drawingPoints = [];
    isDrawing = false;
});


    function addIceberg(polygon){
        polygon=polygon.concat([polygon[0]]);
        let iceberg={polygon:polygon, velocity:[0,0,0]};
        let seen={}; let poly2=[];
        iceberg.polygon.forEach(pt=>{
            const k=pt[0]+"|"+pt[1];
            if(!(k in seen)){seen[k]=true; poly2.push(pt);}
        });
        iceberg.polygon=poly2; iceberg.polygon.push(iceberg.polygon[0]);

        iceberg.area=signedPolygonArea(iceberg.polygon);
        if(iceberg.area<0){iceberg.polygon=iceberg.polygon.reverse(); iceberg.area=Math.abs(iceberg.area);}
        iceberg.rotationalInertia=polygonMomentOfInertia(iceberg.polygon)/Math.sqrt(iceberg.area)/1000000;

        let triangles=turf.tesselate(turf.polygon([iceberg.polygon])).features.map(f=>f.geometry.coordinates[0]);
        triangles=triangles.map(t=>({triangle:t, area:polygonArea(t)/iceberg.area}));
        iceberg.lumpedMassPoints=[];
        for(let i=0;i<250;i++){
            let tR=Math.random(), tX=Math.random(), tY=Math.random(), ti;
            for(ti=0;ti<triangles.length;ti++){
                tR-=triangles[ti].area;
                if(tR<=0||ti==triangles.length-1) break;
            }
            let t=triangles[ti].triangle;
            function interp(r1,r2,a,b,c){return (1-Math.sqrt(r1))*a + (Math.sqrt(r1)*(1-r2))*b + (Math.sqrt(r1)*r2)*c;}
            iceberg.lumpedMassPoints.push({point:[interp(tX,tY,t[0][0],t[1][0],t[2][0]), interp(tX,tY,t[0][1],t[1][1],t[2][1])]});
        }

        let pMassTotal=0;
        iceberg.lumpedMassPoints.forEach(p=>{
            for(let i=0;i<iceberg.polygon.length-1;i++){
                let d=pointSegmentDistance(p.point, iceberg.polygon[i], iceberg.polygon[i+1]);
                if(!p.mass||d<p.mass) p.mass=d;
            }
            pMassTotal+=p.mass;
        });
        iceberg.lumpedMassPoints.forEach(p=>p.mass/=pMassTotal);

        let yMin=null, yMax=null;
        iceberg.polygon.forEach((pt,i)=>{
            if(i==0||pt[1]<yMin) yMin=pt[1];
            if(i==0||pt[1]>yMax) yMax=pt[1];
        });
        iceberg.height=yMax-yMin;
        icebergs=[iceberg];
    }

    // Physics function (unchanged)
    function iceberger(iceberg) {
        const time_scale = 1.1;
        const specific_gravity = 0.92; 
        const yZero = canvas.height / 3;
        const pc = centroid(iceberg.polygon);

        let polygon_submerged = turf.bboxClip(
            turf.polygon([iceberg.polygon]),
            [-Infinity, yZero, Infinity, Infinity]
        ).geometry.coordinates[0];

        if (!polygon_submerged || polygon_submerged.length < 4) polygon_submerged = null;

        const pc_submerged = polygon_submerged ? centroid(polygon_submerged) : [0,0];
        const submerged_ratio = polygon_submerged ? polygonArea(polygon_submerged) / iceberg.area : 0;

        let force = [0,0,0];

        if (iceberg.lumpedMassPoints.length === 0) {
            force[1] += 1;
            if(submerged_ratio>0){
                force[1]-=submerged_ratio/specific_gravity;
                force[2]+=(submerged_ratio/specific_gravity)*(pc_submerged[0]-pc[0]);
            }
        } else {
            iceberg.lumpedMassPoints.forEach(p=>{
                let f=p.mass;
                let s=(p.point[1]-yZero)/(iceberg.height/20);
                s=Math.min(Math.max(s,0),1);
                f-=p.mass/specific_gravity*s;
                force[1]+=f;
                force[2]-=f*(p.point[0]-pc[0]);
            });
        }

        let perimeter=0;
        for(let i=1;i<iceberg.polygon.length;i++){
            const p0=iceberg.polygon[i-1], p1=iceberg.polygon[i];
            const dx=p1[0]-p0[0], dy=p1[1]-p0[1];
            perimeter+=Math.sqrt(dx*dx+dy*dy);
        }

        for(let i=1;i<iceberg.polygon.length;i++){
            const p0=iceberg.polygon[i-1], p1=iceberg.polygon[i];
            let v=[p1[1]-p0[1], -(p1[0]-p0[0])];
            v[0]/=perimeter; v[1]/=perimeter;
            let f=v[0]*iceberg.velocity[0]+v[1]*iceberg.velocity[1];
            if(f<0) continue;
            f*=(1+2*submerged_ratio);
            f=[-v[0]*f, -v[1]*f];
            force[0]+=f[0];
            const mid=[(p0[0]+p1[0])/2,(p0[1]+p1[1])/2];
            let torque=f[0]*(mid[1]-pc[1])-f[1]*(mid[0]-pc[0]);
            if(Math.abs(torque)>1) torque=Math.sign(torque);
            force[2]+=torque;
        }

        let minx=Math.min(...iceberg.polygon.map(pt=>pt[0]));
        let maxx=Math.max(...iceberg.polygon.map(pt=>pt[0]));
        if(minx<0) force[0]+=-minx/canvas.width*10;
        if(maxx>canvas.width) force[0]+=(canvas.width-maxx)/canvas.width*10;

        iceberg.velocity[0]+=force[0]*time_scale;
        iceberg.velocity[1]+=force[1]*time_scale;
        iceberg.velocity[2]+=force[2]/iceberg.rotationalInertia*time_scale;

        const damping_air=0.99, damping_water=0.96;
        const damping=damping_air*(1-submerged_ratio)+damping_water*submerged_ratio;
        iceberg.velocity[0]*=damping;
        iceberg.velocity[1]*=damping;
        iceberg.velocity[2]*=(damping-0.1);

        function update_point(pt){
            pt=rotate(pc[0],pc[1],pt[0],pt[1],iceberg.velocity[2]);
            pt[0]+=iceberg.velocity[0]; pt[1]+=iceberg.velocity[1];
            return pt;
        }
        iceberg.polygon=iceberg.polygon.map(update_point);
        iceberg.lumpedMassPoints.forEach(p=>{p.point=update_point(p.point);});

        iceberg.polygon=iceberg.polygon.map(pt=>{
            if(pt[1]<yZero) pt[1]=(pt[1]-yZero)*0.9999+yZero;
            else pt[1]=(pt[1]-yZero)*0.99999+yZero;
            return pt;
        });
    }

    function getBounds(pts) {
    let minX = pts[0][0], maxX = pts[0][0];
    let minY = pts[0][1], maxY = pts[0][1];
    pts.forEach(p => {
        if (p[0] < minX) minX = p[0];
        if (p[0] > maxX) maxX = p[0];
        if (p[1] < minY) minY = p[1];
        if (p[1] > maxY) maxY = p[1];
    });
    return {
        minX, maxX, minY, maxY,
        width: maxX - minX,
        height: maxY - minY
    };
}
    // --- Classifier ---
function classifyIceberg(iceberg) {
    const pts = iceberg.polygon.slice(0, -1);
    const bounds = getBounds(pts);
    const aspect = bounds.width / bounds.height;

    // 1. Feature Extraction
    const minY = bounds.minY;
    const topPoints = pts.filter(p => p[1] < minY + (bounds.height * 0.2));
    const topWidth = Math.max(...topPoints.map(p => p[0])) - Math.min(...topPoints.map(p => p[0]));
    const flatness = topWidth / bounds.width;

    // 2. Notch Detection (For Drydock)
    // We look for points in the middle-top that are significantly LOWER than the peaks on the sides
    const middlePoints = pts.filter(p => p[0] > bounds.minX + (bounds.width * 0.3) && p[0] < bounds.maxX - (bounds.width * 0.3));
    const middleHighestY = middlePoints.length > 0 ? Math.min(...middlePoints.map(p => p[1])) : minY;
    const notchDepth = (middleHighestY - minY) / bounds.height;

    // 3. Complexity/Symmetry (For Irregular)
    const leftHalf = pts.filter(p => p[0] < bounds.minX + bounds.width/2);
    const rightHalf = pts.filter(p => p[0] >= bounds.minX + bounds.width/2);
    const leftMinY = Math.min(...leftHalf.map(p => p[1]));
    const rightMinY = Math.min(...rightHalf.map(p => p[1]));
    const asymmetry = Math.abs(leftMinY - rightMinY) / bounds.height;

    // 4. Scoring Logic
    const scores = {};

    // Drydock: Deep central notch
    scores['Drydock'] = Math.min(1.0, notchDepth * 3);

    // Tabular: Wide, flat, NO deep notch
    scores['Tabular'] = (aspect > 1.5 ? 1.0 : 0.2) * flatness * (1 - scores['Drydock']);

    // Pinnacle: Sharp peak, low flatness, low notch
    scores['Pinnacle'] = (aspect < 1.0 ? 1.0 : 0.5) * (1 - flatness) * (1 - scores['Drydock']);

    // Wedge: High asymmetry, one-sided slope
    scores['Wedge'] = asymmetry * (1 - flatness);

    // Dome: Rounded, moderate flatness, symmetrical
    scores['Dome'] = Math.max(0, 1 - Math.abs(aspect - 1.2)) * (flatness > 0.3 && flatness < 0.7 ? 1.0 : 0.2);

    // Blocky: Steep sides, flat top, square aspect
    scores['Blocky'] = Math.max(0, 1 - Math.abs(aspect - 1)) * flatness * (1 - scores['Drydock']);

    // Irregular: Doesn't fit the others well, or has high "jitter" in the points
    const baseIrregular = 0.15; // baseline
    scores['Irregular'] = baseIrregular + (asymmetry * 0.5);

    // 5. Normalization
    const total = Object.values(scores).reduce((a, b) => a + b, 0) || 1;
    for (const k in scores) scores[k] = (scores[k] / total * 100).toFixed(1);

    lastClassification = scores;
    renderClassification();
}


    function renderClassification(){
        const el = document.getElementById("classification");
        if(!lastClassification){el.innerHTML="Draw an iceberg to see classification."; return;}
        let html = "Classification probabilities:<br>";
        for(const k in lastClassification){
            html+=`${k}: ${lastClassification[k]}%<br>`;
        }
        el.innerHTML = html;
    }

    // --- Tick loop ---
    function tick(){
    if(drawingInProgress!==null || icebergs.length==0) return;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    draw_background();

    icebergs.forEach(iceberg=>{
        iceberger(iceberg);

        ctx.strokeStyle="black";
        ctx.fillStyle="white";
        ctx.lineWidth=2;
        ctx.lineJoin="round";
        ctx.beginPath();
        ctx.moveTo(iceberg.polygon[0][0],iceberg.polygon[0][1]);
        iceberg.polygon.forEach(pt=>ctx.lineTo(pt[0],pt[1]));
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    });

    ctx.globalAlpha=0.5;
    draw_water();
    ctx.globalAlpha=1;

    // --- PATCH START ---
    // Ensure the classification div updates if an iceberg exists
    if(icebergs.length > 0 && lastClassification){
        renderClassification();
    }
    // --- PATCH END ---
}


    setInterval(tick,50);

});
</script>
</body>
</html>



