<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Iceberg Floating Demo</title>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://unpkg.com/@turf/turf/turf.min.js"></script>
    <style>
        #classification {
            margin-top: 10px;
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body>
    <h1>Iceberg Floating and Classification Model</h1>
    <p>Draw an iceberg cross-section below, see how it floats, and receive a basic classification based on its shape. Please note, pinnacle is not currently supported in this version. Ongoing work to update the classifier is still in progress.

The goal is to show a scientific demo of how iceberg physics works.</p>
    <canvas id="canvas" width="800" height="500" style="border:1px solid black;"></canvas>
    <div id="classification">Draw an iceberg to see classification.</div>

<script>
$(function() {
    const canvas = $("#canvas")[0];
    const ctx = canvas.getContext("2d");

    const yZero = canvas.height / 3;
    let icebergs = [];
    let drawingInProgress = null;
    let lastClassification = null;

    // Draw background
    function draw_background() {
        ctx.fillStyle = "#bbddee";
        ctx.fillRect(0,0,canvas.width,canvas.height);

        // Horizon line
        ctx.beginPath();
        ctx.strokeStyle = "yellow";
        ctx.lineWidth = 1;
        ctx.moveTo(0,yZero);
        ctx.lineTo(canvas.width,yZero);
        ctx.stroke();

       

        draw_water();
    }

    function draw_water() {
        ctx.fillStyle = "#2c7bb6";
        ctx.beginPath();
        ctx.moveTo(0,yZero);
        ctx.lineTo(0,canvas.height);
        ctx.lineTo(canvas.width,canvas.height);
        ctx.lineTo(canvas.width,yZero);
        ctx.closePath();
        ctx.fill();
    }

    draw_background();

    // Geometry utilities
    function signedPolygonArea(vertices) {
        if (!vertices || vertices.length < 3) return 0;
        let total = 0;
        for (let i = 0; i < vertices.length; i++) {
            const addX = vertices[i][0];
            const addY = vertices[i == (vertices.length-1)?0:i+1][1];
            const subX = vertices[i == (vertices.length-1)?0:i+1][0];
            const subY = vertices[i][1];
            total += (addX*addY*0.5);
            total -= (subX*subY*0.5);
        }
        return total;
    }

    function polygonArea(vertices) { return Math.abs(signedPolygonArea(vertices)); }

    function rotate(cx, cy, x, y, angle){
        var rad=(Math.PI/180)*angle, cos=Math.cos(rad), sin=Math.sin(rad);
        var nx=(cos*(x-cx)) + (sin*(y-cy)) + cx;
        var ny=(cos*(y-cy)) - (sin*(x-cx)) + cy;
        return [nx,ny];
    }

    function pointSegmentDistance(p,v,w){
        function sqr(x){return x*x;}
        function dist2(v,w){return sqr(v[0]-w[0])+sqr(v[1]-w[1]);}
        const l2=dist2(v,w);
        if(l2===0) return Math.sqrt(dist2(p,v));
        let t=((p[0]-v[0])*(w[0]-v[0]) + (p[1]-v[1])*(w[1]-v[1]))/l2;
        t=Math.max(0,Math.min(1,t));
        return Math.sqrt(dist2(p,[v[0]+t*(w[0]-v[0]), v[1]+t*(w[1]-v[1])] ));
    }

    function centroid(pts){
        let n=pts.length, off=pts[0], x=0, y=0, f, p1, p2;
        let twicearea=0;
        for (let i=0,j=n-1;i<n;j=i++){
            p1=pts[i]; p2=pts[j];
            f=(p1[0]-off[0])*(p2[1]-off[1])-(p2[0]-off[0])*(p1[1]-off[1]);
            twicearea+=f; x+=(p1[0]+p2[0]-2*off[0])*f; y+=(p1[1]+p2[1]-2*off[1])*f;
        }
        f=twicearea*3;
        return [x/f+off[0], y/f+off[1]];
    }

    function polygonMomentOfInertia(points){
        function sub(a,b){return[a[0]-b[0],a[1]-b[1]];}
        function add(a,b){return[a[0]+b[0],a[1]+b[1]];}
        function mul(p,f){return[p[0]*f,p[1]*f];}
        function dot(a,b){return a[0]*b[0]+a[1]*b[1];}
        function cross(a,b){return a[0]*b[1]-b[0]*a[1];}
        function dist(a,b){b=b||[0,0];return Math.sqrt((a[0]-b[0])**2+(a[1]-b[1])**2);}
        let I=0;
        for(let i=1;i<points.length-1;i++){
            const p1=points[0],p2=points[i],p3=points[i+1];
            const w=dist(p1,p2), w1=Math.abs(dot(sub(p1,p2),sub(p3,p2))/w), w2=Math.abs(w-w1);
            const s=cross(sub(p3,p1),sub(p2,p1))/2;
            const h=2*Math.abs(s)/w;
            const p4=add(p2,mul(sub(p1,p2),w1/w));
            const cm1=[(p2[0]+p3[0]+p4[0])/3,(p2[1]+p3[1]+p4[1])/3];
            const cm2=[(p1[0]+p3[0]+p4[0])/3,(p1[1]+p3[1]+p4[1])/3];
            const I1=w1*h*((h*h/4)+(w1*w1/12)), I2=w2*h*((h*h/4)+(w2*w2/12));
            const m1=0.5*w1*h, m2=0.5*w2*h;
            const I1cm=I1-(m1*dist(cm1,p3)**2), I2cm=I2-(m2*dist(cm2,p3)**2);
            const I1p=I1cm+m1*dist(cm1)**2, I2p=I2cm+m2*dist(cm2)**2;
            if(cross(sub(p1,p3),sub(p4,p3))>0) I+=I1p; else I-=I1p;
            if(cross(sub(p4,p3),sub(p2,p3))>0) I+=I2p; else I-=I2p;
        }
        return Math.abs(I);
    }

    // Scribble drawing
    function add_point(e){
        if(e.touches) e=e.touches[0];
        const rect=canvas.getBoundingClientRect();
        const x=e.clientX-rect.left, y=e.clientY-rect.top;
        drawingInProgress.push([x,y]);
        if(drawingInProgress.length>=2){
            ctx.beginPath();
            ctx.strokeStyle="black"; ctx.lineWidth=3; ctx.lineJoin="round";
            let p=drawingInProgress;
            ctx.moveTo(p[p.length-2][0],p[p.length-2][1]);
            ctx.lineTo(p[p.length-1][0],p[p.length-1][1]);
            ctx.stroke();
        }
    }

    $('#canvas').on('mousedown touchstart', function(e){
        ctx.clearRect(0,0,canvas.width,canvas.height);
        draw_background();
        drawingInProgress=[]; lastClassification=null;
        add_point(e);
    });
    $('#canvas').on('mousemove touchmove', function(e){
        if(drawingInProgress!==null){add_point(e); e.preventDefault();}
    });
    $('#canvas').on('mouseup touchend', function(e){
        if(drawingInProgress.length<3){drawingInProgress=null; return;}
        addIceberg(drawingInProgress);
        classifyIceberg(icebergs[0]);
        drawingInProgress=null;
    });

    function addIceberg(polygon){
        polygon=polygon.concat([polygon[0]]);
        let iceberg={polygon:polygon, velocity:[0,0,0]};
        let seen={}; let poly2=[];
        iceberg.polygon.forEach(pt=>{
            const k=pt[0]+"|"+pt[1];
            if(!(k in seen)){seen[k]=true; poly2.push(pt);}
        });
        iceberg.polygon=poly2; iceberg.polygon.push(iceberg.polygon[0]);

        iceberg.area=signedPolygonArea(iceberg.polygon);
        if(iceberg.area<0){iceberg.polygon=iceberg.polygon.reverse(); iceberg.area=Math.abs(iceberg.area);}
        iceberg.rotationalInertia=polygonMomentOfInertia(iceberg.polygon)/Math.sqrt(iceberg.area)/1000000;

        let triangles=turf.tesselate(turf.polygon([iceberg.polygon])).features.map(f=>f.geometry.coordinates[0]);
        triangles=triangles.map(t=>({triangle:t, area:polygonArea(t)/iceberg.area}));
        iceberg.lumpedMassPoints=[];
        for(let i=0;i<250;i++){
            let tR=Math.random(), tX=Math.random(), tY=Math.random(), ti;
            for(ti=0;ti<triangles.length;ti++){
                tR-=triangles[ti].area;
                if(tR<=0||ti==triangles.length-1) break;
            }
            let t=triangles[ti].triangle;
            function interp(r1,r2,a,b,c){return (1-Math.sqrt(r1))*a + (Math.sqrt(r1)*(1-r2))*b + (Math.sqrt(r1)*r2)*c;}
            iceberg.lumpedMassPoints.push({point:[interp(tX,tY,t[0][0],t[1][0],t[2][0]), interp(tX,tY,t[0][1],t[1][1],t[2][1])]});
        }

        let pMassTotal=0;
        iceberg.lumpedMassPoints.forEach(p=>{
            for(let i=0;i<iceberg.polygon.length-1;i++){
                let d=pointSegmentDistance(p.point, iceberg.polygon[i], iceberg.polygon[i+1]);
                if(!p.mass||d<p.mass) p.mass=d;
            }
            pMassTotal+=p.mass;
        });
        iceberg.lumpedMassPoints.forEach(p=>p.mass/=pMassTotal);

        let yMin=null, yMax=null;
        iceberg.polygon.forEach((pt,i)=>{
            if(i==0||pt[1]<yMin) yMin=pt[1];
            if(i==0||pt[1]>yMax) yMax=pt[1];
        });
        iceberg.height=yMax-yMin;
        icebergs=[iceberg];
    }

    // Physics function (unchanged)
    function iceberger(iceberg) {
        const time_scale = 1.1;
        const specific_gravity = 0.92; 
        const yZero = canvas.height / 3;
        const pc = centroid(iceberg.polygon);

        let polygon_submerged = turf.bboxClip(
            turf.polygon([iceberg.polygon]),
            [-Infinity, yZero, Infinity, Infinity]
        ).geometry.coordinates[0];

        if (!polygon_submerged || polygon_submerged.length < 4) polygon_submerged = null;

        const pc_submerged = polygon_submerged ? centroid(polygon_submerged) : [0,0];
        const submerged_ratio = polygon_submerged ? polygonArea(polygon_submerged) / iceberg.area : 0;

        let force = [0,0,0];

        if (iceberg.lumpedMassPoints.length === 0) {
            force[1] += 1;
            if(submerged_ratio>0){
                force[1]-=submerged_ratio/specific_gravity;
                force[2]+=(submerged_ratio/specific_gravity)*(pc_submerged[0]-pc[0]);
            }
        } else {
            iceberg.lumpedMassPoints.forEach(p=>{
                let f=p.mass;
                let s=(p.point[1]-yZero)/(iceberg.height/20);
                s=Math.min(Math.max(s,0),1);
                f-=p.mass/specific_gravity*s;
                force[1]+=f;
                force[2]-=f*(p.point[0]-pc[0]);
            });
        }

        let perimeter=0;
        for(let i=1;i<iceberg.polygon.length;i++){
            const p0=iceberg.polygon[i-1], p1=iceberg.polygon[i];
            const dx=p1[0]-p0[0], dy=p1[1]-p0[1];
            perimeter+=Math.sqrt(dx*dx+dy*dy);
        }

        for(let i=1;i<iceberg.polygon.length;i++){
            const p0=iceberg.polygon[i-1], p1=iceberg.polygon[i];
            let v=[p1[1]-p0[1], -(p1[0]-p0[0])];
            v[0]/=perimeter; v[1]/=perimeter;
            let f=v[0]*iceberg.velocity[0]+v[1]*iceberg.velocity[1];
            if(f<0) continue;
            f*=(1+2*submerged_ratio);
            f=[-v[0]*f, -v[1]*f];
            force[0]+=f[0];
            const mid=[(p0[0]+p1[0])/2,(p0[1]+p1[1])/2];
            let torque=f[0]*(mid[1]-pc[1])-f[1]*(mid[0]-pc[0]);
            if(Math.abs(torque)>1) torque=Math.sign(torque);
            force[2]+=torque;
        }

        let minx=Math.min(...iceberg.polygon.map(pt=>pt[0]));
        let maxx=Math.max(...iceberg.polygon.map(pt=>pt[0]));
        if(minx<0) force[0]+=-minx/canvas.width*10;
        if(maxx>canvas.width) force[0]+=(canvas.width-maxx)/canvas.width*10;

        iceberg.velocity[0]+=force[0]*time_scale;
        iceberg.velocity[1]+=force[1]*time_scale;
        iceberg.velocity[2]+=force[2]/iceberg.rotationalInertia*time_scale;

        const damping_air=0.99, damping_water=0.96;
        const damping=damping_air*(1-submerged_ratio)+damping_water*submerged_ratio;
        iceberg.velocity[0]*=damping;
        iceberg.velocity[1]*=damping;
        iceberg.velocity[2]*=(damping-0.1);

        function update_point(pt){
            pt=rotate(pc[0],pc[1],pt[0],pt[1],iceberg.velocity[2]);
            pt[0]+=iceberg.velocity[0]; pt[1]+=iceberg.velocity[1];
            return pt;
        }
        iceberg.polygon=iceberg.polygon.map(update_point);
        iceberg.lumpedMassPoints.forEach(p=>{p.point=update_point(p.point);});

        iceberg.polygon=iceberg.polygon.map(pt=>{
            if(pt[1]<yZero) pt[1]=(pt[1]-yZero)*0.9999+yZero;
            else pt[1]=(pt[1]-yZero)*0.99999+yZero;
            return pt;
        });
    }

    // --- Classifier ---
    function classifyIceberg(iceberg){
        const pts = iceberg.polygon;
        const width = Math.max(...pts.map(p=>p[0])) - Math.min(...pts.map(p=>p[0]));
        const height = Math.max(...pts.map(p=>p[1])) - Math.min(...pts.map(p=>p[1]));
        const aspect = width/height;

        const scores = {};
        scores['Tabular'] = Math.max(0, 1 - Math.abs(aspect-3)/3);
        scores['Wedge'] = Math.max(0, 1 - Math.abs(aspect-0.5)/1);
        scores['Dome'] = Math.max(0, 1 - Math.abs(aspect-1)/1);
        scores['Pinnacle'] = Math.max(0, 1 - Math.abs(aspect-0.25)/0.5);
        scores['Blocky'] = Math.max(0, 1 - Math.abs(aspect-0.8)/1);
        scores['Drydock'] = Math.max(0, 1 - Math.abs(aspect-2)/2);
        scores['Irregular'] = Math.max(0, 1 - Math.abs(aspect-1.5)/2);

        const total = Object.values(scores).reduce((a,b)=>a+b,0);
        for(const k in scores) scores[k] = (scores[k]/total*100).toFixed(1);

        lastClassification = scores;
        renderClassification();
    }

    function renderClassification(){
        const el = document.getElementById("classification");
        if(!lastClassification){el.innerHTML="Draw an iceberg to see classification."; return;}
        let html = "Classification probabilities:<br>";
        for(const k in lastClassification){
            html+=`${k}: ${lastClassification[k]}%<br>`;
        }
        el.innerHTML = html;
    }

    // --- Tick loop ---
    function tick(){
        if(drawingInProgress!==null || icebergs.length==0) return;
        ctx.clearRect(0,0,canvas.width,canvas.height);
        draw_background();

        icebergs.forEach(iceberg=>{
            iceberger(iceberg);

            ctx.strokeStyle="black";
            ctx.fillStyle="white";
            ctx.lineWidth=2;
            ctx.lineJoin="round";
            ctx.beginPath();
            ctx.moveTo(iceberg.polygon[0][0],iceberg.polygon[0][1]);
            iceberg.polygon.forEach(pt=>ctx.lineTo(pt[0],pt[1]));
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        });

        ctx.globalAlpha=0.5;
        draw_water();
        ctx.globalAlpha=1;
    }

    setInterval(tick,50);

});
</script>
</body>
</html>



